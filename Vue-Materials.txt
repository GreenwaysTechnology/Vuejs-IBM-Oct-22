				Vue.js
.....................................................................................

Pre Knowledge:

1.HTML 5
2.CSS 3
3.Javascript ES 5 and Es 6 
4.node js fundamentals - npm

Nice to have
1.React/Angular
.....................................................................................

Lab setup:

1.node.js
2.vs code
....................................................................................

What is Vue.js?
  Vue js is a javascript framework for building user interfaces

What is User interface?
  The application where user interacts.

Types of user interface application:

1.Desktop applications
2.Web Applications which is running inside browser
3.Mobile Applications
   Native
   Browser based 
   Hybrid Mobile Application
4.Other devices based Apps


Web Applications:
.................
 The application is built and distributed over internet and accessed by using http protocal.

Types of web application:

Server side Web Application:
.............................
1.Static web apps - 1989 to 1995
https://home.cern/science/computing/where-web-was-born

2.Dynamic Content Generation Web App - 1996 to till date
  -CGI - C,Perl
  -J2EE - Java, Servlet
  -ASP - VbScript, vb
  -PHP - PHP
  -.net,nodejs,ruby..rails....
Output: HTML pages generated on fly.

3.Biz to Biz integration:
   Incase two biz organization want to share their information via internet
 DCG technology was not enough.
 Web Services:  1998 to till Date
  COMMON DATA Interchange format
   instead of exchanging html pages we can exchange data in the form of XML
  -XML - Soap Web Services
 2005 on wards - REST Full web services
,.............................................................................

Client side Web Apps:

Browser based :
 Desktop browsers
 Mobile browsers

 Powered with HTML With Javascript 
    Incase of dynamic web apps, html genereated by server and javascript changed and processed html pages at client side.


In 2007,W3c Introduced new web development arch, called "Single Page Web Application/SPA"

In SPA

 Client user interface applications were written using "HTML 5,CSS3,Javascript" where as server side applications are "Web Services-REST API" which serves data to the client.

SPA:
       Client User App (HTML,CSS,JS)<-------------------> REST API

SPA Frameworks:
1.Mustache.js
2.Angular.js
3.React
4.Angular
5.Vue.js
.....................................................................................
			  Client Side Web Technology.

There are there primary languages 
1.HTML 5
2.Javascript 
3.CSS

DOM Programming:
................
What is DOM?

What is HTML? How it works?

HTML is the programming language,DSL / Declarative Programming languge. Domain specific language- Domain specific language is nothing but the language built for sepcific domain, which cant be used for other purposes.

HTML internal work flow:
.......................
index.html -  source code

<html>
 <head>
   <title>HTML</title>
 </head>
 <body>
     <h1>Welcome</h1>
 </body>
</html>
 --------------Browser
  |
 loader : load source code into browser
  |
  uses protocal 
   file or http
  |
  parser : Parser is spcial compiler which converts source code into lexical tree
           (String tree)
   |

html
  head
   title
      HTML
   title
 head
 body
     h1
      Welcome
     h1
 body
html
   |
   compiler: Compilation: convert source code into assembly language
   |
html - LOAD XXX
  head-
   title
      HTML
   title
 head
 body
     h1
      Welcome
     h1
 body
html
.......................&&&&&&&&&&&&&..........................................  
                                Runtime

During runtime, we need to allocate memory for the program.

Runtime will create LinkedList(c) for the entire html document

html - Node
  head-
   title
      HTML
   title
 head
 body -Node
     h1  - Node
      Welcome
     h1
 body
html

Nodes are connected each other in Hierchical Structure(Tree)

Linking the Nodes (Tree)

body -Node
    |
     h1  - Node
      |
        Welcome
     h1
 body
 |
Layout Engine/Paint Engine
   |
  will convert into pxs - Final Ouput

            At End , the html page is "Tree Data Structure"
..........................***.....................................................
			The Netscap Communication and HTML Tree
.................................................................................
Netscap started a project,to access rendered "tree" via program.

Netcap initally decided to introduce c program,later who decided to change their mind to "Java".
Java was not also not suitable , the reason was , java was the big language , putting the language inside browser is not suitable.

Nets cap finally decided who did not want eiter c or java, but java like language
 - "The Birth of Javascript" 

The Javascript was introduced  as light weight programming language to access the tree,process the tree.

How to reprsent html inside javascript engine?
 
 Netscap took an idea "Object" Model.

Every html element is object, which is created once the browser loads the html into browser,and also object can be created using apis..

Javascript engins forms the tree called "Object Tree"
.....................................................................................
			Netscap Object and W3c
.....................................................................................

After Object tree model and javascript success, W3C  decided to standarize this arch/technology.

After standarization, w3c publish a spec called "DOM" -  Document Object Model

How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                Every Html ELEMENT Inside Browser is "C Program"

	        Every Html ELEMENT Inside javascript engine is "Object"

HTML Elements(p,h1,div,img) are  represented inside browser as "Node", inside Javascript Engine "Object - DOM "


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.

.....................................................................................
				DOM Programming
.....................................................................................

How to implement dom programming?

1.using plain js
  if we use plain js , it is very difficult to build large applications

2.using frameworks and libs

2000 - The first javascript framework - DOJO
2002-2005 - JQuery - is the second most powerfull dom lib.
After 2006 - many js libs and frameworks introduced.. 2008(Angular js) 2013(react)...

Popular DOM frameworks/lib:
1.React
2.Angular
3.Vue.js
.....................................................................................
			 Vue Application Types

Vue.js is a framework used to build different types of client side apps

1.Standalone script application
   Enchancing html(genereated by server) by adding javascript /js lib(jquery)
 
if you have traditional web apps written using server side techn like jsp,asp,php which has "js/jquery" lib

    Vue is Declarative  replacement of Imperative "Jquery"


2.Web Component
    Vue supports to create web component arch based applications

3.Single Page Web Application(SPA)
   Vue is Primarily popuplar for building spa applications

4.Full Stack /SSR - Server side Rendered apps.
 
  SSR =  SPA + Server Side Technologies

 Pure SPA's has limitations when the app is sensitive to SEO and time to constent.
 Every thing happens in the browser side with respective SPA.

 Vue apps can be compiled/render in the server side.
 Server will generate html pages before sending to the browser(client) - Pre  rendering.
 https://nuxtjs.org/ -  for ssr with vuejs

5.SSG/JAMStack
   Server side static file generation(96), instead of build dynamic apps, suppose we need static apps.

  Server-side rendering can be done ahead of time if the required data is static. This means we can pre-render an entire application into HTML and serve them as static files.

 This improves site performance and makes deployment a lot simpler since we no longer need to dynamically render pages on each request. 

Vue can still hydrate such applications to provide rich interactivity on the client. This technique is commonly referred to as Static-Site Generation (SSG), also known as JAMStack.

The Vue team maintains a static-site generator called VitePress, which powers this website you are reading right now! In addition, Nuxt also supports SSG. You can even mix SSR and SSG for different routes in the same Nuxt app.

https://jamstack.org/

vue supported frameworks - VitePress,Nuxt


  
Beyond the Web:
...............

Although Vue is primarily designed for building web applications, it is by no means limited to just the browser. You can:

Build desktop apps with Electron or Tauri
Build mobile apps with Ionic Vue
Build desktop and mobile apps from the same codebase with Quasar
Use Vue's Custom Renderer API to build custom renderers targeting WebGL or even the terminal!
....................................................................................

App selections:

Whether your app is legacy server side apps built using j2ee or .net,php,rails--->
 Standalone vue.js

Your app is api centeric(webservices)/microservices
   Vue can be used as "SPA"

SPA With SSR for better optimization and SEO ready

SPA and SSR With SSG/JAM Stack - where your app is having static data
.....................................................................................
			   Getting started with Vue App
....................................................................................

Development work flows:

1.Without Build Tool
2.With Build Tool


1.Without Build Tool:

Project Setup:
..............

1.without build tools

2.with build tools


1.without build tools

Steps:

1.create Project

>mkdir vue-legacy

vue-legacy>mkdir src

create index.html outside src dir

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue-legacy</title>
</head>
<body>
    
</body>
</html>

in order to integrate vue with existing html

you have to add script which is distributed by vue community via "cdn".

There are two builds:
1.dev build
2.prod build

Dev Build

<script src="https://unpkg.com/vue@3"></script>

You are running a development build of Vue.
Make sure to use the production build (*.prod.js) when deploying for production.


Prod Build
 <script src="https://unpkg.com/vue@3.1.1/dist/vue.global.prod.js"></script>
....................................................................................
Core concepts of Vue
....................
			   Vue Application

Vue is just javascript framework, offers apis,infrastructure to build "DOM" programming.

DOM Programming:
1.create element or elements 
   When we create elements we create tree model-DOM tree
2.update existing elements content
3.remove/delete existing element content and element itself
4.list/walk through tree
5.we may change style dynamically
6.we interact with ui and change the ui.

Vue is javascript dom programming framework 

There are two ways of programming in UI:

1.imperative programming
    The way of write program using complex logics, more boiler plate code.
eg:
  create element using plain js
  create element using jQuery

   <div id="root">

    </div>
    <script>
        function createElement() {
            console.log('create Element')
            const Heading = document.createElement('h1')
            Heading.innerHTML = 'Hello DOM!'
            Heading.style.color = 'blue'
            document.getElementById('root').appendChild(Heading)
        }
        createElement();
    </script>

2.declarative programming

 =>write less code
 =>Abstract DOM apis with readable constructs 
 =>introduce declarative templates

Note:
 Template driven technology introduced in server side computing in 1990's
 2006, the first template driven technology was introduced in javascript called
 mustache.js ( {{}}})
 Template = static + dynamic  content , where dynamic content is interpolated into code. 
 eg <h1>Hello {{name}} </h1>

 "Vue is based on declarative , which extends standard HTML with a template syntax"
				+
			   java script => binds the state(data)/ biz logic

HTML + Extra Syntax + Bizlogic+data = Vue.js
.....................................................................................
How vue represents UI?

=>Vue creates UI dynamically(DOM)
=>Vue organizes the UI into smaller and smaller UI
=>VUE breaks the complex UI into Smallary UI
    This model is called called as "Compostion"

Why Compostion?
=>The UI can be reused any where in the app and also outside app.
=>The code maintaince is very easy,because it is independant.

	    "The arch is called as Component Driven Arch"

Component means parts of something.
.....................................................................................
			 Vue Instance /Application Object
.....................................................................................

In vuejs, the whole application(User interface), is composed into the object called
"Vue instance".

Pro Vue 3

var app = new Vue({})

Vue 3:
We can get Vue instance:

 1.Via Globale Vue Variable
 2.Via ES  6 Modules


			A.Via Global Vue variable
...................................................................................
Getting Vue instance:
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/vue@3"></script>

</head>
<body>
    <h1>Vue Application</h1>
    <script>
        // Vue instance via global variable
        const vue = Vue 
        console.log(vue)
    </script>
</body>
</html>



Vue is Root Instance having lot methods (factory methods)

createApp: (...args) => {…}
createBlock: ƒ createBlock(type, props, children, patchFlag, dynamicProps)
createCommentVNode: ƒ createCommentVNode(text = '', // when used as the v-else branch, the comment node must be created as a // block to ensure correct updates. asBlock = false)
createElementBlock: ƒ createElementBlock(type, props, children, patchFlag, 


Create Application:
.................

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/vue@3"></script>

</head>

<body>
    <h1>Vue Application</h1>
    <script>
        // Vue instance via global variable
        const vue = Vue
        //Create Application;
        const app = vue.createApp()
        console.log(app)
    </script>
</body>

</html>
.....................................................................................
			 Short cuts to get Apis
.....................................................................................

Object Destructuring:
....................
 Object destructuring is es 6 feature to break the object properties for easy readability.

<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/vue@3"></script>

</head>

<body>
    <h1>Vue Application</h1>
    <script>
        //create application instance short -1
        //   const app = Vue.createApp()
        //   console.log(app)
        //object destructuring syntax
        const { createApp } = Vue
        const app = createApp()
        console.log(app)

    </script>
</body>

</html>
....................................................................................
			B.Via Es 6 modules
.....................................................................................

can we use es 6 modules directly inside browser

name.js
export const name='Subramanian'

index.js
import {name} from './name'

Generally browser has no facility to link files and share code using "ES 6 modules keyword "

How to run es 6 module based apps inside browsers

Solution:
1.Using build tools - webpack,rollup.
   React,angular uses this tool behind it.

2.Using browser alone
   using type=module

 Recently browsers vendors added a capability to link files at browser level, this is still in experimental mode- many browsers(old browsers may not support)

Dont Try this in production.

1.using the property called type="module" in the script section.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>     
</head>
<body>    
    <script src="src/index.js" type="module"></script>
</body>
</html>

src/name.js
export const firstName ='Subramanian'
export const lastName ='Murugan'

src/index.js
import { firstName,lastName } from './name.js'

console.log(`${firstName} ${lastName}`) 
....................................................................................
			 Vue js and es 6 modules


2.Using browser alone
   Dynamically Import JavaScript with Import Maps

if you want import any js code within html file.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>    
    <script type="importmap">
        {
          "imports": {
          
          }
        }
      </script> 
</head>
<body>    
    <!-- <script src="src/index.js" type="module"></script> -->

</body>
</html>

Note:
Import Maps Browser Support

Import maps are supported by default in Chromium-based browsers, so we recommend using Chrome or Edge during the learning process.

If using Firefox, it is only supported in version 102+ and currently needs to be enabled via the dom.importMaps.enabled option in about:config.

If your preferred browser does not support import maps yet, you can polyfill it with es-module-shims.

    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>

Not for production

The import-maps-based setup is meant for learning only - if you intend to use Vue without build tools in production, make sure to check out the Production Deployment Guide.

eg:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- Polyfil lib for importmap -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
</head>

<body>
    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
            "name":"./src/name.js"
          }
        }
    </script>
    <script type="module">
        import { createApp } from 'vue'
        import {firstName} from 'name'

        const app = createApp()
        console.log(app)
        console.log(firstName)
    </script>
</body>

</html>
.....................................................................................
			  User interface Development
.....................................................................................

User interface development guidelines:

1.User interface must be broken into smallar and smallar -  Compostion - Component model

2.User interface is organized in hierachal structure -  Tree Structure 
  Thats where html has been designed.
 We need to follow html tree model

 <div>
    <div>
	<div>
	   
	</div>
	
    </div>
 </div>

3.In tree model there must be one root element
..................................................................................
				Root Component(root Element)


In React:
 function Logo(){
   
   return <img src="logo.png"/>
 
}
In Angular

 @Component({
   selector:'app-logo'
   template:`<img src="logo.png"/>
 }) 
 export class Logo{

 }
In Vue:
 Component is object which is represented as literal object.

const Logo ={

}
What component contains:

 component information can be categorized into various segments

1.UI/Rendering - HTML,CSS(Markup)
..................................
 template
 render
 compilerOptions

2.State -(data) - javascript
 data 
 props
 computed
 methods
 watch
 emits
 expose

3.Life Cycle hooks(methods)
beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeUnmount
unmounted
errorCaptured
renderTracked
renderTriggered
activated
deactivated
serverPrefetch

4.Composition
 provide
 inject
 mixins
 extends


Misc
name
inheritAttrs
components
directives

Component Instance api
$data
$props
$el
$options
$parent
$root
$slots
$refs
$attrs
$watch()
$emit()
$forceUpdate()
$nextTick()

const Logo ={
  ui: {},
  state:{}
  others:{}
  methods:{} 
}
....................................................................................
				Vue Coding style
....................................................................................
Vue coding can be classified into two category

Vue 2.X and Vue 3.X

Api classification:
...................

1.Options Api Based Style - Vue 2.x Style
2.Composition Api Based Style  -Vue 3.x Style

Create Component:
................
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- Polyfil lib for importmap -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
</head>

<body>

    <!-- container where you inject your app(DOM) -->
    <div id="root">

    </div>

    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
          }
        }
    </script>
    <script type="module">
        import { createApp } from 'vue'
        const app = createApp({
            template: `
                <h1>Hello Vue!</h1>
            `
        })
        console.log(app)
        //i want to mount/
        // app.mount(document.getElementById('root'))
        app.mount("#root")

    </script>
</body>

</html>
.....................................................................................
			 	  How to write modular code

1.you have to write application component in a separate folders and files

src
 |
 components
    |
    App.js
index.html


src/components/App.js

//Application Component 
export default {
    template: `
        <h1>Vue Application</h1>
    `
}

index.html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <!-- Polyfil lib for importmap -->
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.5.5/dist/es-module-shims.js"></script>
</head>

<body>

    <!-- container where you inject your app(DOM) -->
    <div id="root">

    </div>

    <script type="importmap">
        {
          "imports": {
            "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js",
            "app" :"./src/components/App.js"
          }
        }
    </script>
    <script type="module">
        import { createApp } from 'vue'
        import  Application  from 'app'
        const app = createApp(Application)
        console.log(app)
        app.mount("#root")

    </script>
</body>

</html>
.....................................................................................
			Vue Application Setup using Build Tools
....................................................................................

Build tools are js based tools for create,manage js apps work flows.
Build tools based on npm tool.

Setup Vue Project using build tool based: CLI based apporach.
.............................................................

There are two cli tools

1.Vue-cli
  https://cli.vuejs.org/#getting-started
Vue- cli is now in maintance mode, meaning that , which is only used for creating old vue project(v2)

2.Vite
https://vitejs.dev/guide/
Next Generation Frontend Tooling project, used to create no of project types.

We are going to follow Vite base project setup

npm init vue@latest

This is abstraction for vite based project templates

>npm init vue@latest

vue-cli
 old pattern
vite
 modern pattern - recommended
 npm init vue@latest

This is abstraction for vite based project templates

>npm init vue@latest
Need to install the following packages:
  create-vue@latest
Ok to proceed? (y) y

Vue.js - The Progressive JavaScript Framework

√ Project name: ... vue-app
√ Add TypeScript? ... No / Yes
√ Add JSX Support? ... No / Yes
√ Add Vue Router for Single Page Application development? ... No / Yes
√ Add Pinia for state management? ... No / Yes
√ Add Vitest for Unit Testing? ... No / Yes
√ Add Cypress for both Unit and End-to-End testing? ... No / Yes
√ Add ESLint for code quality? ... No / Yes
√ Add Prettier for code formatting? ... No / Yes


Done. Now run:

  cd vue-app
  npm install
  npm run lint
  npm run dev

Folders and file Structure:
..........................
package.json
{
  "name": "vue-app",
  "version": "0.0.0",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview --port 4173"
  },
  "dependencies": {
    "vue": "^3.2.38"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^3.0.3",
    "vite": "^3.0.9"
  }
}

vite.config.js
 To configure build tool
import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})
index.html
 Root /landing page , where it kicks starts app work flow.

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

src
 |
 assets
 components
 App.vue
 main.js

assets folder contains all basic css files ,images,documents
components folder contains components 

App.vue
  Root Component for the application, mostly components are saved with "fileName.vue"

main.js
 entry file for any vue application
import { createApp } from 'vue'
import App from './App.vue'
import './assets/main.css'

createApp(App).mount('#app')
.....................................................................................
			 Components Creational Patterns
....................................................................................

1.Plain Java script Pattern

App.js
export default {
  
  ...options 
  
}

It is more imperative way of creating components

2.Single File Components -SFC

 It is more declarative way of creating components
 As name suggest, All Component logic inside single file.

Components have three major segment:

1.template 
   collection of html elements and vue instructions
2.javascript
   collection of variables,methods
3.style 
   css style for a component


In SFC Pattern, we isloate very clearly into three sections

<script>
   ....All javascript code
</script>
<template>
  ...template code
</template>
<style>
 //style for this component
</style>


Plain javascript pattern is usefull where there is no build workflow,SFC is usefull and necessary in build tool work flow 

		  SFC components are saved with fileName.vue
		Plain javascript pattern files are saved with fileName.js


App.vue

<!-- Three segments -->
<script>
</script>
<template>
    <h1>Hello Vue!</h1>
</template>
<style>
</style>
		
...................................................................................
                               Vue App -Coding Style
...................................................................................
			        Vue App
				   |
			---------------------------------------  
			With Build tool                  without build tool
				 |				|
			SFC Component            	 Script based (refer above)
				   |
	----------------------------------------------------------------
        |                                                             |
        |                                                             |

      Options Api                                              Composition Api
	 |                                                          |
   Vue 2 based apps                                           Vue 3 based apps

Note: Even though you work in vue3, still Vue2 based apporach works..

....................................................................................
			Commonality between both patterns

1.code segementation is same
  <script></script>
  <template></template>
  <style></style>

Options Api Pattern:
......................
In options Api Pattern, we return Options Object , which contains neccessary configurations.

<script>
 //return options object
 export default {
    //options

 }
<script>


eg:

<!-- Options Api Pattern -->
<script>
//you have to return Options Object
export default {
    props:['something'],
    data() {
        return {
            name: 'Subramanian'
        }
    }
}
</script>
<template>
    <h1>Components Using Options Api Pattern</h1>
</template>
<style>

</style>
....................................................................................
			  Composition Api Pattern

In this pattern we define a component logic's using imported Api functions
In this pattern we write code directly inside script.

		          Composition Api Pattern
				  |
		----------------------------------------------------
		|                                                  |
	      with setup function                          with setup attribute				


With Setup function:
...................
1.Looks like Options api pattern but code refactoring done.
2.It looks like imperative style of compostion apis.

<!-- Compsition pattern with setup function -->
<script>
export default {
    setup() {
        //all js initalization code will go here
    }
}
</script>
<template>
</template>
<style>

</style>

With setup attribute:
....................

1.vue compiler writes all boiler plate code for us.

<!-- Compsition pattern with setup attribute -->
<script setup>
// you can write app logic directly : which looks like regular js code
</script>
<template>
    <h1>Single File Component with Composition api with setup attribute</h1>
</template>
<style>

</style>


 				Vue App
				   |
			---------------------------------------  
			With Build tool                  without build tool
				 |				|
			SFC Component            	 Script based (refer above)
				   |
	----------------------------------------------------------------
        |                                                             |
        |                                                             |

      Options Api                                              Composition Api
	 |                                                          |
   Vue 2 based apps                                           Vue 3 based apps
							        												|	
		  							|
				----------------------------------------------------
				|                                       |
	      	with setup function                           with setup attribute	
.....................................................................................
				How to create components
....................................................................................

How to structure a Large scale vue.js app

Default strcture

src
  |
  components
    |
    User 
    Product
    Comments
    Payment

Standard Structure of apps would be domain model

src
  |
  components
    |
    User 
      Userlist.vue
      UserDetails.vue
      User.vue
   Product	
      ProductList.vue
      ProductDetails.vue
      Product.vue
   stores
   layouts
   plugins
   directives
   helpers/utils
....................................................................................
			Component Composition 

Organization of Components in hierachical order(tree) pattern

<div id="root">
    <App>
	<Hello></Hello>
    </App>
</div>

eg:

Component with "Options API"
 
In this pattern, component must be registered inside script
using component key

src/components/greeter/Hello.vue
<script>
</script>
<template>
    <h2>Hello</h2>
</template>
<style>
</style>

src/components/greeter/App.vue
<script>
import Hello from "./components/greeter/Hello.vue";

export default {
    components: { Hello }
}
</script>
<template>
    <div>
        <h1>App</h1>
        <Hello></Hello>
    </div>
</template>
<style>

</style>
..................................................................................
Component Registration with composition pattern with setup function:
......................................................................
<script>
import Hello from "./components/greeter/Hello.vue";
export default {
    components: { Hello,Hai },
    setup() {
    }
}
</script>
<template>
    <div>
        <h1>App</h1>
        <Hello></Hello>
    </div>
</template>
<style>

</style>
.................................................................................	Component Registration with composition pattern with setup attribute:
......................................................................
<script setup>
import Hello from "./components/greeter/Hello.vue";

</script>
<template>
    <div>
        <h1>App</h1>
        <Hello></Hello>
    </div>
</template>
<style>

</style>	   
....................................................................................

Assigment-1:
............
Create Layout Components

1.header
   |
   Logo
   SearchPanel
   LoginPanel
2.main
   |
   three sections
    -Vue features
3.Footer
   |
   Sponors
   copyright

You have to try

1.Options api
2.Compositions api with imperative (setup fun) and declarative Patterns (setup attr)

...................................................................................
............................&&&&&&&&&&..............................................
			    Component Registeration -Creations
.....................................................................................

A Vue component needs to be "registered" so that Vue knows where to locate its implmeneation when it is encountered in a template.

Two Types of Registeration:

1.Global Registeration
  Global Components
2.Local Registeration
  Local Components

Global Components:
  Components are created and  registered as part of the application object
  Global Components can be accessed any where in the application without explicit   configuration

Application object having lot of methods
app.component()
app.use()
app.provide()
etc...
https://vuejs.org/api/application.html#app-component

import { createApp } from 'vue'

const app = createApp({})

// register an options object
app.component('my-component', {
  /* ... */
})

// retrieve a registered component
const MyComponent = app.component('my-component')

.....................................................................................
eg:
src/components/StatusBar.vue
<script setup>
</script>
<template>
    <h2>Status Bar!!</h2>
</template>
<style>
</style>

src/main.js

import { createApp } from 'vue'
import App from './App.vue'
import StatusBar from './components/global/StatusBar.vue'
import './assets/main.css'
// console.log(App)

const app = createApp(App)

app.component('StatusBar', StatusBar)


app.mount('#app')

src/App.vue
<script>
import StatusBar from './components/global/StatusBar.vue';
export default {
    //components: { StatusBar }
}

</script>
<template>
    <StatusBar></StatusBar>
</template>
<style>
</style>

Short cut inside main.js
import { createApp } from 'vue'
import App from './App.vue'
import StatusBar from './components/global/StatusBar.vue'
import './assets/main.css'
// console.log(App)
// const app = createApp(App)
// app.component('StatusBar', StatusBar)
// app.mount('#app')

createApp(App)
    .component('StatusBar', StatusBar)
    .mount('#app')

Note:
 Here incase the component is part of application object(Global Component), we need not register with components using {components:CompName}
....................................................................................

			 Local Components Registration
................................................................................

Components are registered when the child component is created

SFC using composition pattern using setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'
</script>

<template>
  <ComponentA />
</template>

SFC using composition pattern using without setup attribute:

Greeter.vue
<script setup>
  import ComponentA from './ComponentA.vue'

export default {
   components: { 
         ComponentsA
   }
}
</script>

<template>
  <ComponentA />
</template>

..................................................................................
			Both local and global compoents
...................................................................................
<script>
import StatusBar from './components/global/StatusBar.vue';
import Hello from './components/greeter/Hello.vue';
export default {
    components: { Hello } //Local Component Registration,we tell to the vue engine that when ever you encounter this , create instance for this component.
}
</script>
<template>
    <StatusBar></StatusBar>
    <Hello></Hello>
</template>
<style>
</style>
,,,,,,,,,,,,,,,,,,,,..................,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
...................................................................................
			Global Vs Local Component Registration
.................................................................................

=>Global registration prevents build systems from removing unused components (a.k.a "tree-shaking").
=>If you globally register a component but end up not using it anywhere in your app, it will still be included in the final bundle.

=>Global registration makes dependency relationships less explicit in large applications. 

=>It makes it difficult to locate a child component's implementation from a parent component using it.

=>This can affect long-term maintainability similar to using too many global variables.

=>Global Components need to be imported inside any where

<script>
// import StatusBar from './components/global/StatusBar.vue';
import Hello from './components/greeter/Hello.vue';
export default {
    components: { Hello } //Local Component Registration,we tell to the vue engine that when ever you encounter this , create instance for this component.
}
</script>
<template>
    <StatusBar></StatusBar>
    <Hello></Hello>
</template>
<style>
</style>
....................................................................................
....................................................................................
			 Component Naming Conventions
.....................................................................................

PascalCase names are valid JavaScript identifiers. This makes it easier to import and register components in JavaScript. It also helps IDEs with auto-completion.

<PascalCase /> makes it more obvious that this is a Vue component instead of a native HTML element in templates. It also differentiates Vue components from custom elements (web components).

This is the recommended style when working with SFC or string templates. However, as discussed in DOM Template Parsing Caveats, PascalCase tags are not usable in DOM templates.

The Component names can be kebab-case /dash case eg
   <app-root>
   <hello-world>
   <greeter>
Vue supports both cases , but highly recommened is Pascal Case

eg:
<script>
//import StatusBar from './components/global/StatusBar.vue';
import Hello from './components/greeter/Hello.vue';
export default {
    //Hello is just Component
    components: { Hello } //Local Component Registration,we tell to the vue engine that when ever you encounter this , create instance for this component.
}
</script>
<template>
    <!-- Pascal Case -->
    <!-- <StatusBar></StatusBar> -->
    <!-- <Hello></Hello> -->
    <!-- dash-case/ kebab-case -->
    <status-bar></status-bar>
    <hello></hello>
</template>
<style>

</style>
.....................................................................................
			    Templates
...................................................................................
Template is the representation of View
View is Runtime representation

Template can be static or dynamic 

Static templates are having pure html code
Dynamic templates are having html code + Vue instructions
Vue instructions are special symbols
  
Template  = html + vue instructions (data,events,props)

Data Binding:
.............
  Passing data from the Component to View and View to Component

Types of Data bidning:

1.interpolation
2.property /props binding
3.attribute binding
4.event binding
5.Two way data binding
6.class and style binding
.....................................................................................
			  MVC  Architecture
....................................................................................

In order to build user interface we have architectures

1.MVC 
  It is the most legacy arch but still more popular arch, used in server side,client   side app developments

2.Flex 
   It is discovered by face book, in order to replace MVC , primarily used in React..

Vue js is MVC Based  and Flex mixed arch -hybrid arch..

M - Model - State - Data
V - View  - User interface
C - Controller - Having data and biz logic

Vue and MVC:
<script>
   // M + C ->logic
</script>
<template> 
   View logic 
</template>
<style>
</style>
...................................................................................
				Interpolation
....................................................................................

Transfering data(state) from (controlller) to View.

State:
  State Can be represented in two ways
1.primitives - numbers,strings,boolean
  let name='subramanian'
  let salary=100
  let isValid=true
2.objects and collections -  literal object,arrays
  
  let profile = {
    id:1,
    name:'Arun'
  }
  let profiles = [{
    id:1,
    name:'Arun'
  },{
    id:2,
    name:'Bala'
  }]

SFC:
 1.Using Options api
 2.Using Composition api
    -with setup fun
    -withut setup fun.


1.Using Options api
  Encapsulate options inside literal object

let options = {
   data:?
   props:?
   methods:?
}

Exploring Options Api

let options = {
   data:function(){
	return {state...}
   }
}
data is function which encapulates state(model)
data function must return object which encapsulate "state"

es 6 way of writing functions:
let options = {
   data(){
	return {state...}
   }
}

How to bind data inside template which was returned from the "data" function.

{{variableName}} - interplation
.....................................................................................
src/App.vue

State + Options Api 
<script>
export default {
    //data
    data() {
        //Models 
        return {
            firstName: 'Subramanian',
            lastName: 'Murugan',
            status:true,
            points:100,
            address: {
                city:'Coimbatore'
            }
        }
    }
}
</script>
<template>
    <h1>Name {{firstName}} {{lastName}}</h1>
    <h2>Status {{status}}</h2>
    <h2>Points {{points}}</h2>
    <h2>City {{address.city}}</h2>
</template>
<style>

</style>
....................................................................................

State Representation and data binding with Composition Api:
..........................................................

1.<script> with setup function
2.<script setup> with setup attribute

<script> without setup attribute:
.................................

The component logic must be encapsulated inside a function called "setup"

export default {

 setup(){

   return {} //must return state
 }

}

eg:
<script>
export default {
    setup() {
        //state declarations 
        const firstName = 'Subramanian'
        const lastName = 'Murugan'
        //encapsulate this data into object
        // return {
        //     firstName: firstName,
        //     lastName:lastName
        // }
        return {
            firstName, lastName // es 6 destructuring stynax
        }
    }
}
</script>
<template>
    <h1>Name {{firstName}} {{lastName}}</h1>
</template>
<style>

</style>
....................................................................................

2.<script setup> with setup attribute

<script setup>
//state declarations 
const firstName = 'Subramanian'
const lastName = 'Murugan'
</script>
<template>
    <h1>Name {{firstName}} {{lastName}}</h1>
</template>
<style>

</style>

=><script setup> is compile time syntactic sugar for composition API inside SFCs
=>It is highly recommended syntax if you are using both SFCs and compostion API
=>It offers lot benefits over normal syntax

 1.More readable code with less boilerplate
 2.Better Runtime Performance
 3.Render performance
 4.Better IDE support

code segments inside script setup

1.variable declarations
2.function declarations
3.import other components and utiltity functions


<script setup>
import Hello from "./components/greeter/Hello.vue";
//state declarations 
const firstName = 'Subramanian'
const lastName = 'Murugan'
//function declarations
const fullName = () => `${firstName} ${lastName}`
</script>
<template>
    <h1>Name {{firstName}} {{lastName}}</h1>
    <h1>Name {{fullName()}}</h1>
    <Hello></Hello>
</template>
<style>

</style>
.....................................................................................
				Directives
....................................................................................

What is directive?
  Directive is object which helps to create custom elements and attributes.
  Directives enchances existing html elements - We extend the functionality of HTML   elements.
  We are going to add new behaviour to the HTML elements.

Vue is highly modular framework, code Resue is Main Objective.

Code Resue Patterns:
...................

1.Components
2.Composables(Hooks)
3.Directives


Components are main building blocks.
Composable are focused on "Resuing stateful logic" - Data isloation.
Directives are mainly intented for resuing logic that involes low level DOM Acess on Plain Elements -DOM Element features.

HTML elements Types:

1.Built in element and attributes
2.Custom elements and attributes

<h1>Hello</h1> -  built in element

HTML Compiler Work flow:
.......................


<h1>Hello</h1> -----Compiler verfies this element is built in or not
				|
		   --------------------------------
		   |                              |
                 Yes                             No
		  |                              |
Browser parses the                    Brower throws exception called "UnknownElement"
element and convert                   which is converted into plain ascii node
it , render accordingly


<app-drawer> - it is custom element, generally browser does not under stand.

In 2007, W3c introduced new idea that developers can add their own tags/elements(custom elements and custom attributes)
   HTML 5 Specification

In built element logic is already written, so that browser easily understands that.

What about custom element, how to teach browser to understand custom elements?
    
  "Through Javascript"

<app-drawer> ---|JS Code--->Runs ---renders in the browser....
   
eg:
<script setup>
import AppDrawer from './components/drawer/AppDrawer.vue'
</script>
<template>
<h1>Drawer App</h1>
<!-- Custom element -->
<app-drawer></app-drawer>
</template>
<style>

</style>

src/componnets/drawer/AppDrawer.vue
<script setup>
</script>
<template>
    <p>Drawer Element</p>
</template>
<style>
</style>

               "Every Component is a Custom element only"

.....................................................................................
			Custom Attributes
.....................................................................................

1.Built in element Attributes

 <img src="" alt="">
       |      |
   Attributes - Built in attributes

Browser knows how to put logic to src and alt.

2.Custom attributes on existing html elements

<img customAttribute />
        | 
     custom attribute
How to teach browser to parse custom Attributes 
  "Through Javascript"

eg: Vue rendered page:

<div id="app" data-v-app="">
<h1>Drawer App</h1>
 <!-- Custom element --><p>Drawer Element</p>
</div>
.....................................................................................
Vue.js Helps to add Custom attributes on existing elements via "Directives" -Attribute Directives
.....................................................................................

Vue js attribute directive syntax:
v-directiveName

Built in Directives:
...................
v-text
v-html
v-show
v-if
v-else
v-else-if
v-for
v-on
v-bind
v-model
v-slot
v-pre
v-once
v-memo
v-cloak

Special Attributes
key
ref
is
.....................................................................................
			    v-html and v-text
...................................................................................

v-html :
 inserts data into html element as "HTML"
{{}} 
  inserts data into html element as "Plain Text"

				v-text

Update the element's text content. - innerText

<script setup>
//variable
const name = 'Subramanian'
</script>
<template>
    <h1>Interpolation using mustace notation</h1>
    <h2>Name {{name}}</h2>
    <h1>Interpolation using using Directives-text </h1>
    <h2 v-text="`name ${name}`"></h2>
    <h1>Interpolation using using Directives-html </h1>
    <h2 v-html="`name ${name}`"></h2>
</template>
<style>

</style>
....................................................................................
			 v-bind
...................................................................................

V-binds html attributes values or components values(properties) dynamically.

Binding: Attach value to the attribute

Static Binding
  <img src="logo.png"/>
here value of src cant be changed once the ui rendered

Dynamic Binding
 <img v-bind:src="variableHoldingImage" /> 
Short cut:
 <img :src="variableHoldingImage" /> 
  here v-bind is implicit

<script setup>
 const imageUrl ="/src/assets/logo.svg"
 const isEnabled = true 
 const isHidden = true
</script>
<template>
    <h1>Bind Directives</h1>
    <div>
        <h2>Static Binding</h2>
        <img src="./assets/logo.svg" height="100" width="100" />
    </div>
    <div>
        <h2>Dynamic Binding using v-bind Directive</h2>
        <img v-bind:src="imageUrl" height="100" width="100" />
    </div>
    <div>
        <h2>Dynamic Binding using v-bind Directive with Short cut</h2>
        <img :src="imageUrl" height="100" width="100" />
    </div>
    <div>
        <h2>Dynamic Binding using v-bind Directive</h2>
        <button :disabled="isEnabled">Enable</button>
    </div>
    <div>
        <article :hidden="isHidden">
             <p>This is vue article</p>
        </article>
    </div>
</template>
<style>

</style>
.....................................................................................
			Component Driven Design principles
.....................................................................................

Role of Components / Responsibility of Component:
..................................................

Component having state,bizlogic,ui

As per component design design principles , we need to apply modularity concept.
  Break the component based on two aspects

1.Having data and biz logic
    -Parent Component /Container component
2.Having UI logic
    -Child Component/Presentational Component


Data(State) Sharing Patterns/ Data(State) Representation Patterns:
....................................................

1.Props Pattern
  The data is shared from the Parent Component to Child Component.
2.State Pattern

If you want understand the component hierachy ,so that it is easy to explore how data is shared.

Vue dev tool
https://devtools.vuejs.org/guide/installation.html


Parent Component
   <ProductDetails title="Product Details" ></ProductDetails>
                     |            |
                  PropertyName   Property value


Props Handling:
Using options Api

src/components/products/ProductMaster.vue
<script setup>
import ProductDetails from "./ProductDetails.vue";
</script>
<template>
    <h2>Product Master</h2>
    <hr>
    <ProductDetails title="Product Details" ></ProductDetails>
</template>
<style>
</style>

src/components/products/ProductDetails.vue
<!-- Options Api Pattern -->
<script>
export default {
    props: ['title']
}
</script>
<template>
 <div>
    <h1>{{title}}</h1>
 </div>
</template>
<style>
</style>
....................................................................................
				Prop types:


1.static prop
	props value are passed only one time , hardcoded values
 
<ProductDetails title="Product Details" ></ProductDetails>

2.dynamic prop
        props values are passed during rendering, dynamailly you can pass value.
  state as prop: the state of compoent can be passed as prop to another props

<ProductDetails v-bind:title="title" ></ProductDetails>
<ProductDetails :title="title" ></ProductDetails>


eg:
<script setup>
import ProductDetails from "./ProductDetails.vue";

const title = 'Product Details!!'
</script>
<template>
    <h2>Product Master</h2>
    <hr>
    <!-- <ProductDetails title="Product Details" ></ProductDetails> -->
    <ProductDetails :title="title"></ProductDetails>
</template>
<style>

</style>
<!-- Options Api Pattern -->
<script>
export default {
    props: ['title']
}
</script>
<template>
 <div>
    <h1>{{title}}</h1>
 </div>
</template>
<style>
</style>
.....................................................................................
				Prop inside Composition Api


With setup function
<!-- Options Api Pattern -->
<script>
export default {
    props: ['title'],
    setup() {
        
    }

}
</script>
<template>
    <div>
        <h1>{{title}}</h1>
    </div>
</template>
<style>

</style>

what if i want to access props inside setup function?

<script>
export default {
    props: ['title'],
    setup() {
        console.log(this.props)
	console.log(props)
    }

}
</script>
Both will throw error?
Uncaught ReferenceError: props is not defined
    at setup (ProductDetails.vue:6:21)
    at callWithErrorHandling (runtime-core.esm-bundler.js:155:22)
    at setupStatefulComponent (runtime-core.esm-bundler.js:7187:29)
    at setupComponent (runtime-core.esm-bundler.js:7142:11)
    at mountComponent (runtime-core.esm-bundler.js:5491:13)
    at processComponent (runtime-core.esm-bundler.js:5466:17)
    at patch (runtime-core.esm-bundler.js:5068:21)
   
soultion:
  we have to declare arg variable for setup function, vue actually injects
props into that variable.

<!-- Composition Api Pattern -->
<script>
export default {
    props: ['title'],
    setup(props) {
        console.log(props.title)
        return {
            props
        }
    }
}
</script>
<template>
    <div>
        <h1>{{title}}</h1>
    </div>
</template>
<style>

</style>
....................................................................................
			 Props inside Setup Attribute
...................................................................................
Vue offers an composable function called "defineProps"

<!-- Composition Api Pattern -->
<script setup>
const props = defineProps(['title'])
// export default {
//     props: ['title'],
//     setup(props) {
//         console.log(props.title)
//         return {
//             title : props.title
//         }
//     }
// }

</script>
<template>
    <div>
        <h1>{{props.title}}</h1>
        <h1>{{title}}</h1>
    </div>
</template>
<style>

</style>
.....................................................................................
					Default Props

what if i dont supply any props, then it will be undefined

With props  supplied
 <DyamicProp :name="name" :age="age" :status="status"></DyamicProp>

without any props supplied
<DyamicProp></DyamicProp>
   here all properties will be undefined.
	    
Property declaration syntax:
syntax:1
const props = defineProps(['title'])
syntax:2
const props = defineProps({
   //prop meta data
    title: {
	default: 'Detault Product Details'
    }
})
eg:
src/components/products/ProductMaster.vue

<script setup>
import ProductDetails from "./ProductDetails.vue";

const title = 'Product Details!!'
</script>
<template>
    <h2>Product Master</h2>
    <hr>
    <!-- <ProductDetails title="Product Details" ></ProductDetails> -->
    <!-- <ProductDetails :title="title"></ProductDetails> -->
    <ProductDetails></ProductDetails>
    <ProductDetails :title="title"></ProductDetails>

</template>

<style>

</style>

src/components/products/ProductDetails.vue

<script setup>
//const props = defineProps(['title'])
const props = defineProps({
    title: {
        default: 'Default Props'
    }
})
</script>
<template>
    <div>
        <h1>{{props.title}}</h1>
    </div>
</template>
<style>

</style>
....................................................................................
			 Property Validation
....................................................................................

Some times i want to enforce the property data type validation, which is only for runtime vertification.

eg:
 i have property called age
 i need to define rule for age that age must be number,it should not be string.

eg:
  defineProps({
     age:Number,  
     id: [Number,String] // can be string or can be number
     name: {
      type:String
      required:true,
      default:'name'
     },
    status: {
	validator(value){
	  return ['OK','NotOk','Success','Failure'].includes(value)
       }
    }
 })

Runtime Types:
1.String
2.Number
3.Boolean
4.Array
5.Object
6.Date
7.Function
8.Symbol


<script setup>
//const props = defineProps(['title'])
const props = defineProps({
    title: {
        type:String,
        default: 'Default Props'
    }
})
</script>
<template>
    <div>
        <h1>{{props.title}}</h1>
    </div>
</template>
<style>

</style>

<script setup>
import ProductDetails from "./ProductDetails.vue";

const title = 'Product Details!!'
const intTitle = 100
</script>
<template>
    <h2>Product Master</h2>
    <hr>
    <!-- <ProductDetails title="Product Details" ></ProductDetails> -->
    <!-- <ProductDetails :title="title"></ProductDetails> -->
    <ProductDetails></ProductDetails>
    <ProductDetails :title="title"></ProductDetails>
    <ProductDetails :title="intTitle"></ProductDetails>


</template>

<style>

</style>

runtime-core.esm-bundler.js:38 [Vue warn]: Invalid prop: type check failed for prop "title". Expected String with value "100", got Number with value 100. 
  at <ProductDetails title=100 > 
  at <ProductMaster> 
  at <App>
.....................................................................................
			One way data flow Model
.....................................................................................
All props forms a one way data flow model, where child component cant update the properties

			"Props are read only"

<script setup>
//const props = defineProps(['title'])
const props = defineProps({
    title: {
        type:String,
        default: 'Default Props'
    }
})
//update property - props are read only
props.title = "something"
</script>
<template>
    <div>
        <h1>{{props.title}}</h1>
    </div>
</template>
<style>

</style>

reactivity.esm-bundler.js:4 [Vue warn] Set operation on key "title" failed: target is readonly. Proxy
warn @ reactivity.esm-bundler.js:4
reactivity.esm-bundler.js:4 [Vue warn] Set operation on key "title" failed: target is readonly. Proxy
warn @ reactivity.esm-bundler.js:4
runtime-core.esm-bundler.js:38 [Vue warn]: Invalid prop: type check failed for prop "title". Expected String with value "100", got Number with value 100. 
  at <ProductDetails title=100 > 
  at <ProductMaster/>
.....................................................................................
         	 	State Pattern


The data(state) can be any type (primitives,objects,arrays).

State can be classified into two category

1.Non Reactive
2.Reactive

Non Reactive:
 if you have state, if you change(mutate) , the ui never re render

Reactive 
 if you have state , if you mutate, the UI starts re render, updates the last state on the ui.

<!-- Non Reactive State -->
<script>
export default {
    setup() {
        //declare state : non reactive
        const counter = 0

        //return object
        return {
            counter
        }
    }
}
</script>
<template>
    <div>
        <h1>Counter App-With NonReactive State</h1>
        <h2>Counter {{counter}}</h2>
    </div>
</template>
<style>

</style>

if you want to change the counter, we need  to interact with UI, we need event handling
.....................................................................................
			   Event Handling
....................................................................................
Event handling is one of the most popular concept in javascript as part of DOM programming.
Event handling helps to interact with user.
Events  are signals triggered by user or system, send to os system, the software or hardware reacts according to the event.

Events are classified into two category

1.Hardware events
   Triggered by user or system, interacts with hardware devices   
eg:
  Mouse events
    onclick,ondblclick,onmouseenter...
  https://www.w3schools.com/jsref/obj_mouseevent.asp
  Keyboard events
   onkeypress,onkeydown
  https://www.w3schools.com/jsref/event_onkeypress.asp
  Touch events
  ontouchstart,ontouchend
  https://www.w3schools.com/jsref/obj_touchevent.asp

2.Application events
   attached with objects called dom objects
  onload,oncomplete

...................................................................................
				How event handling works

Event handling has been designed based on the design pattern called "pub-sub"/observer design pattern.

There are two actors:
1.Producer
   The producer is something who sends signals(events - name of the event and data assoicated) to the listener
2.Listener
  The Listener is someone who waits/listens for event.
  Once the event is given who reacts/respond

n js :
 Listener is function.

//event is just reference to the Event Object having information about event, and data
function listener(event){
     event.target.value
}
event object is a bridge between producer and listener

In javascript , events are given by language itself.

events are started with "on+eventName" - 
 onclick="listener"

addEventListener('click',listener)
listeners are plain js functions with event object reference arg

Frameworks like vue,react,angular who adds their own abstractions.

We can attach event on any dom element which could be application or hardware

Vue Js and event handling:
..........................

Vue attaches events with any element with help of directive
                          "v-on"

Syntax:
1. v-on:NameOftheEvent="listener" -  v-on:click="update"
2. @click="listener" - @click="update"

Event Handling : Options Api Pattern:
......................................

<script>
export default {
    //event handlers
    methods: {
        //arg
        //event is just variable points to "EventTarget Object":Bridge object between listener and DOM element
        hello(event) {
            console.log(event)
            console.log('Hello event is triggered')
        },
        hai() {
            console.log('Hai event is triggered')
        }
    }
}
</script>
<template>
    <button v-on:click="hello">Hello</button>
    <button @click="hello">Hai</button>

</template>
<style>

</style>
...................................................................................
        Event Listener with compostion pattern using setup function
...............................................................................

<script>
export default {
    setup() {
        //declare listener - es 5
        // function hello(evt) {
        //     console.log(evt)
        //     console.log('hello')
        // }
        // function hai() {
        //     console.log('hai')
        // }
        //declare event listener -es 6 arrow functions
        const hello = (evt) => {
            console.log(evt)
            console.log('hello')
        }
        const hai = () => console.log('hai')
        
        return {
            hello, hai
        }
    }
}
</script>
<template>
    <button v-on:click="hello">Hello</button>
    <button @click="hai">Hai</button>

</template>
<style>

</style>
...................................................................................
        Event Listener with compostion pattern using setup attribute
...............................................................................
<script setup>
const hello = (evt) => {
    console.log(evt)
    console.log('hello')
}
const hai = () => console.log('hai')
</script>
<template>
    <button v-on:click="hello">Hello</button>
    <button @click="hai">Hai</button>

</template>
<style>

</style>
.................................................................................
			....................................................................................
		 How to attach more than one listener on single DOM Element
...................................................................................

<dom v-on:eventName="listener" v-on:eventName="listener">
<dom v-on="{mouseenter:onMouseEnter,mouseleave:onMouseLeave}">

<script setup>
const onMouseEnter = (evt) => {
    console.log(evt)
    console.log('mouse enter')
}
const onMouseLeave = () => console.log('mouse leave')
</script>
<template>
    <div v-on="{mouseenter:onMouseEnter,mouseleave:onMouseLeave}">
        Touch
    </div>
</template>
<style>

</style>
..............................................................................
..................................................................................
			  How to pass data to the event listener
..................................................................................
const getData = (data,event) => {
    console.log(data,event)
}
 <button @click="getData('hello',$event)">Pass Data</button>

when we pass data to the listener, vue cant  pass event implicitly, we have to pass event object explicitly via "$event" which is global event object provided by vue.
....................................................................................
			 Reactive State
...................................................................................

Options Api with Reactive State and How to mutate them?
  State + Event Handling


data: 
 method which always returns reactive state

data() {

 //reactive state 
 return {
    count:0
 }
}
eg
<script>

export default {
    data() {
        //return reactive state object
        return {
            count: 0
        }
    },
    methods: {
        //listener
        inc() {
            //mutate the reactive variable
            this.count++ //mutation
        }
    }
}

</script>
<template>
    <div>
        <h1>Reative State Using Options Api</h1>
        <h1>Counter : {{count}}</h1>
        <button @click="inc">+</button>
    </div>
</template>
.....................................................................................
			State Update using Composition Api
...........................................
<script>

export default {
    setup() {

        //state
        let count = 0
        //listener
        const inc = () => {
            console.log(count)
            count++
        }

        return {
            count,
            inc
        }
    }
}

</script>
<template>
    <div>
        <h1>Reative State Using Options Api</h1>
        <h1>Counter : {{count}}</h1>
        <button @click="inc">+</button>
    </div>
</template>

After running this code, 
	Here we are trying to mutate/update the "count" state variable, there is update happening but it does not trigger "view update"
....................................................................................
			   Reactivity
....................................................................................

What is Reactivity?
  Reactivity is one of the core vue js concept.
Component state are "reactive javascript objects"

The word reactivity means "changing" the state(object),whenever changes happen it publishes some events, based on events,reactions happens.

Programming work flow in general

int x =10;
int y =20;

int result = x + y

when you compute this code, the runtime will execute instructions top-down pattern.
if there is change in variable (like x or y), will not update result variable
 -Sequential programming model.

What if i want to update the "result" variable value automatically when ever x or y changes.

eg:
Excel spreed sheet is one of the best eg for reactivitity programming

eg;

let A1=1
let A2=2
let A3 =A1+A2
console.log(A3) => 3

A2=4
console.log(A3) => 5

Here when you mutate A1 or A2, does not change automatically.

We can wrap this code inside function

 let A3
 function update(){
   A3 = A1 + A2
 }

in order get fresh value, we have to re-run the code that updates A3

Pointers:

1.There should be some update function, which produces a "side effect /effect".
  if any function which changes the state of the program called side effect.

2.Here ,A1 and A2 are considered dependencies of the side effect, because which helps makes side effects.
  According to dependencies, this effect is said to be "subscriber"

When ever "A1 and A2" changed, we need to invoke "update" function,which cause side effects.

It looks like event driven programming (Pub-Sub Pattern /Observerable and Observer) 

 function whenDepChange(update){
     update()
 }

 let A3
 function update(){
   A3 = A1 + A2
 }

 whenDepChange(function(){
     A3 = A1 + A2
 })
 whenDepChange(update)

Role of whenDepchange function:
................................

1.Tracking the dependencies,
    By evaulating the expression A1 and A2 ,Whether any one of them is read or not.

Tracker--->triggers--whenDepChange--->runs update function---returns modified state
	
...................................................................................
			  Vue js and Reactivity


Vue js uses "Reactivity subsystem" in order to track all state variables, when ever which changes happen, it inform the vue engine for re render process..


In Options Api pattern,

export default {
  
  data(){
   let count =0
    return {
      count:count
    }
  }

}
inside data function , if you return object, by default it is reactive, meaning that any changes detected, it starts re render ui.


In Compostion api pattern: whether is setup fun or setup attribute

<script>
export default {
 
   setup() {
    let count =0;
	return {
	  count:count
       }
   }  

}
</script>
by default setup function /setup attribute does not return reactive state..(it is normal object)

In options api every property we return is reactive, but in compostion api we can restrict reactive and non reactive.

How to declare reactive state/ how to attach reactivity feature?

Compostion Api reactive methods:
................................
ref()
computed()
reactive()
readonly()
watchEffect()
watchPostEffect()
watchSyncEffect()
watch()

ref():
 It is function which returns Object, not value

function ref<T>(value: T): Ref<UnwrapRef<T>>

interface Ref<T> {
  value: T
}
....................................................................................
			   Ref
<script>
import { ref } from 'vue'
export default {
    setup() {
        //state -normal variable
        //let count = 0
        //reactive
        let count = ref(0)
        console.log(count)
        //listener
        const inc = () => {
            count.value++
        }

        return {
            count,
            inc
        }
    }
}

</script>
<template>
    <div>
        <h1>Reative State Using Options Api</h1>
        <!-- Inside template ref Object's value property is resolve automatically, we dont need to use .value -->
        <h1>Counter : {{count}}</h1>
        <button @click="inc">+</button>
    </div>
</template>
.....................................................................................
			  Ref with Setup attribute
....................................................................................
<script setup>
import { ref } from 'vue'
//reactive
let count = ref(0)
//listener
const inc = () => {
    count.value++
}
</script>
<template>
    <div>
        <h1>Reative State Using Options Api</h1>
        <!-- Inside template ref Object's value property is resolve automatically, we dont need to use .value -->
        <h1>Counter : {{count}}</h1>
        <button @click="inc">+</button>
    </div>
</template>
...................................................................................
			Multiple listeners for single state
....................................................................................
<script setup>
import { ref } from 'vue'
//reactive
let count = ref(0)
//listener
const inc = () => {
    count.value++
}
//listener
const dec = () => {
    count.value--
}
</script>
<template>
    <div>
        <h1>Reative State Using Options Api</h1>
        <!-- Inside template ref Object's value property is resolve automatically, we dont need to use .value -->
        <h1>Counter : {{count}}</h1>
        <button @click="inc">+</button>
        <button @click="dec">-</button>

    </div>
</template>
................................................................................
			Multiple reactive state variables
...............................................................................
<script setup>
import { ref } from 'vue'
//reactive
let like = ref(1)
let dislike =ref(100)
//listener
const onLike = () => {
    like.value++
}
//listener
const onDislike = () => {
    dislike.value--
}
</script>
<template>
    <div>
        <h1>Reactive State</h1>
        <h1>Like : {{like}} Dislike {{dislike}}</h1>
        <button @click="onLike">Like</button>
        <button @click="onDislike">Dislike</button>

    </div>
</template>
....................................................................................
			how Can we mutate state without listener
...................................................................................
Using inline event handler
  <button @click="like++">Like</button>

<script setup>
import { ref } from 'vue'
let like = ref(1)
let dislike =ref(100)
</script>
<template>
    <div>
        <h1>Reactive State</h1>
        <h1>Like : {{like}} Dislike {{dislike}}</h1>
        <button @click="like++">Like</button>
        <button @click="dislike++">Dislike</button>
    </div>
</template>
....................................................................................
			  Reactive Objects
....................................................................................

As of now, we have declared reactive primtive variables, so how to declare reactive state.
 
let count = ref(0) //primitive variable

let comments = reactive({
  like:0,
  dislike:100
})

<script setup>
import { reactive } from 'vue'

const comments = reactive({
    like:0,
    dislike : 0
})

</script>
<template>
    <div>
        <h1>Reactive State</h1>
        <h1>Like : {{comments.like}} Dislike {{comments.dislike}}</h1>
        <button @click="comments.like++">Like</button>
        <button @click="comments.dislike++">Dislike</button>
    </div>
</template>

=>Reactive Conversion(changes) are even updated for deep nested objects 
=>Reactive api compares every property in the object before ui re renders for changes.

let obj={
 
  a:1
  b: {
    c: {
     d: {
	e:0
     }
    }
  }

}

Deep nesting:
<script setup>
import { reactive } from 'vue'

//deep nesting
const comments = reactive({
    like: 0,
    dislike: 0,
    recommend: {
        rating: {
            value: 0
        }
    }
})

</script>
<template>
    <div>
        <h1>Reactive State</h1>
        <h1>Like : {{comments.like}} Dislike {{comments.dislike}} Rating {{comments.recommend.rating.value}}</h1>
        <button @click="comments.like++">Like</button>
        <button @click="comments.dislike++">Dislike</button>
        <button @click="comments.dislike++">Dislike</button>
        <button @click="comments.recommend.rating.value++">Rating</button>

    </div>
</template>
.....................................................................................
		  How to avoid deep conversion with Reactive Nested object		.....................................................................................

shallowReactive:
  shallow version of reactive()
 Unlike reactive there is no deep conversion.... only root properties are reactive 

<script setup>
import { shallowReactive } from 'vue'

//deep nesting
const comments = shallowReactive({
    like: 0,
    dislike: 0,
    recommend: {
        rating: {
            value: 0
        }
    }
})

</script>
<template>
    <div>
        <h1>Reactive State</h1>
        <h1>Like : {{comments.like}} Dislike {{comments.dislike}} Rating {{comments.recommend.rating.value}}</h1>
        <button @click="comments.like++">Like</button>
        <button @click="comments.dislike++">Dislike</button>
        <button @click="comments.dislike++">Dislike</button>
        <button @click="comments.recommend.rating.value++">Rating</button>

    </div>
</template>
.....................................................................................
				List Rendering -Arrays
....................................................................................
Arrays:
 =>Arrays are basic datastructure which is used to render collection of data
 =>Arrays are dynamic

Arrays and UI:
 if you want render more data, then array is used.
Arrays can help to build in UI layouts in various ways


UI layouts:
 are built with help of arrays.

1.List View
 <ul>
   <li>
 </ul>
2.Card View layout
  <div><header><section>

3.Grid view
  table

.....................................................................................
			   v-for directive
....................................................................................
 
 This directive used for array rendering and object rendering.

<ul>
 <li v-for="(variable,index) in array">
</ul>

<script setup>
import { reactive} from 'vue'
import TODOS from './mock-data/todos'
//deep nesting
const todos = reactive(TODOS)

</script>
<template>
    <div>
      <ul>
        <li v-for="todo in todos">
          <span>{{todo.title}}</span>
        </li>
      </ul>

    </div>
</template>
....................................................................................
			   List with Index
....................................................................................
<script setup>
import { reactive} from 'vue'
import TODOS from './mock-data/todos'
//deep nesting
const todos = reactive(TODOS)

</script>
<template>
    <div>
      <ul>
        <li v-for="(todo,index) in todos">
          <!-- <span>{{index}} {{todo.title}}</span> -->
          <span>{{todo.title}}</span>
        </li>
      </ul>

    </div>
</template>
.....................................................................................
			   Key
....................................................................................
if there is re ordering in the list when we do some changes like sorting, filtering 
vue uses an alogorthim called "path"

We can tell to that alogrthim we can re arrange , that where key attribute comes into picture

Key's value must be unique.

<script setup>
import { reactive} from 'vue'
import TODOS from './mock-data/todos'
//deep nesting
const todos = reactive(TODOS)

</script>
<template>
    <div>
      <ul>
        <li v-for="(todo,index) in todos" :key="todo.id">
          <!-- <span>{{index}} {{todo.title}}</span> -->
          <span>{{todo.title}}</span>
        </li>
      </ul>

    </div>
</template>
....................................................................................
			   Nested List
...................................................................................

The outter arry is iterated with "Item in Array"
The inner array is iterated with "Item of NestedArray"
<script setup>
import { reactive } from 'vue'

const persons = [
    {
        id: 1,
        name: 'A',
        friends: [
            {
                name: 'F1'
            },
            {
                name: 'F2'
            },
            {
                name: 'F3'
            }
        ]
    },
    {
        id: 2,
        name: 'B',
        friends: [
            {
                name: 'BF1'
            },
            {
                name: 'BF2'
            },
            {
                name: 'BF3'
            }
        ]
    },
    {
        id: 3,
        name: 'C',
        friends: [
            {
                name: 'CF1'
            },
            {
                name: 'CF2'
            },
            {
                name: 'CF3'
            }
        ]
    }
]

const list = reactive(persons)

</script>
<template>
    <div>
        <ul>
            <li v-for="person in list">
                <span>{{person.name}}</span>
                <ul>
                    <li v-for="friend of person.friends">
                            <span>{{friend.name}}</span>
                    </li>
                </ul>
            </li>
        </ul>

    </div>
</template>

.....................................................................................
			  Object and V-for directive
...................................................................................
<script setup>
import { reactive } from 'vue'

const movie = {
    title:'The Matrix',
    language: ['English','Spanish','Hindi','Tamil','Telgu'],
    hours:['2 hrs 5 mins']
}
const tmpMovie = reactive(movie)

</script>
<template>
    <div>
        <ul>
            <li v-for="movie in tmpMovie">
                  {{movies}}
            </li>
        </ul>

    </div>
</template>
...................................................................................
			 Range and V-for
..................................................................................

<script setup>
import {ref} from 'vue'

const start = ref(1)

</script>
<template>
    <div>
        <ul>
            <li v-for="start in 100">
                  {{start}}
            </li>
        </ul>

    </div>
</template>
....................................................................................
				Lab
...................................................................................

1.You have to render list of Users from the array
  https://jsonplaceholder.typicode.com/users

Display field:
 UserName
2.When you click on Each user Name, you have to display the complete other user details
  
  1 details
  name:XXX
  email:XXX
    
  address:
    XXX
    geo
  phone
  website
  company
     XXXX

Here you have to create a separate Address Component,geo component, from the user component each user address must be passed as prop.
 
  <User>
    <Address>
     <Geo>
 </User>
.....................................................................................
				Array Mutations
.....................................................................................

Push,remove,update array elements

<script setup>
import { reactive } from 'vue';
const todos = reactive([])
//listener
const addItem = () => {
    todos.push({ id: Math.random(), text: 'Learn Vue!' })
}
</script>
<template>

    <ul>
        <li v-for="todo in todos">
            <span>{{todo}}</span>
        </li>
    </ul>
    <button @click="addItem">AddItem</button>
</template>
<style>

</style>

In vue all apis will not trigger render cycle..

Api which trigger's render cycle - Mutating apis

1.push
2.pop
3.shift
4.unshift
5.splice
6.sort
7.reverse
...................................................................................
			 Filtering/Sorting arrays with immutable api
...................................................................................

What is immutable api?

 when ever we do any changes on object, instead of changing original object changes, which creates a new copy of the object- immutable.

eg:
  if you add new item into array, the runtime will create new array,instead of mutating original memory.

Array immutable apis:
 map,filter,reduce - immutable apis
 or 
 you can use even spread operator or Object.assign method

<script setup>
import { ref } from 'vue'
import TODOS from './mock-data/todos'
//deep nesting
const todos = ref(TODOS)

const filter = () => todos.value = todos.value.filter(todo => todo.completed)
</script>
<template>
    <div>
        <button @click="filter">Filter By Status</button>
        <h1>Total items : {{todos.length}}</h1>
        <ul>
            <li v-for="(todo,index) in todos" :key="todo.id">
                <span>{{todo.title}}</span>
            </li>
        </ul>

    </div>
</template>
....................................................................................
				Object Destructuring
.....................................................................................

Object Destrucing is es 6 feature, used to extract object properties, to write more readable code.

<script setup>
// function display(profile) {
//     console.log(profile.id)
//     console.log(profile.name)
//     console.log(profile.address.city)
// }
function display(profile) {
    //destrcturing sytax;
    const { id, name, address: { city } } = profile
    console.log(id)
    console.log(name)
    console.log(city)
}
display({
    id: 1,
    name: 'Subramanian',
    address: {
        city: 'Coimbatore'
    }
})
</script>
<template>
    <h1>Object destructuring</h1>
</template>
..................................................................................
			 Reactivity and Object Destruturing
...................................................................................
<script setup>
import { reactive } from 'vue';

const {id,name,address: {city}} = reactive({
    id: 1,
    name: 'Subramanian',
    address: {
        city: 'Coimbatore'
    }
})
</script>
<template>
    <h1>Object destructuring and Reactivity</h1>
    <h1>Id {{id}}</h1>
    <h1>Name{{name}}</h1>
    <h1>City {{city}}</h1>

</template>
...................................................................................
		   Reactivity ,State Mutation,and Object Destructuring
...................................................................................
After reactive object destructuring , can we state mutations?
  Reactivity will be lost once if the object is destructured..

How to convert destructured property into Reactive?

1.toRef - single property
2.toRefs - multiple property
<script setup>
import { reactive, toRef, toRefs } from 'vue';
// const location = reactive({
//     lat: 10.5,
//     lng: 90.5
// })
//destructuring and reactivity
// let { lat, lng } = toRefs(location)
let { lat, lng } = toRefs(reactive({
    lat: 10.5,
    lng: 90.5
}))

const updateLocation = () => {
    lat.value = 100.89
    lng.value = 78.67
}
</script>
<template>
    <h1>Object destructuring and Reactivity</h1>
    <h1>Lat : {{lat}} {{lng}}</h1>
    <button @click="updateLocation">Update Location</button>
</template>
....................................................................................
			 Computed Properties
...................................................................................
In the template, if you write any javascript expressions like computing length, total of stock value, finding total price...
It is not recommended.. using js code, rather what we can use "declarative code" - Computed properties..

<script setup>
import { computed, reactive } from 'vue';

const author = reactive({
    name: 'Subramanian',
    trainings: [
        'Vue 3 Basic to intermediate',
        'MicroServices using Spring Cloud'
    ]
})
//computed Property: 
const isTrainingHandled = computed(() => {
    return author.trainings.length > 0 ? 'Yes' : 'No'
})

</script>
<template>
    <!-- Immperative way of handling js expressions -->
    <!-- <h1>{{author.name}}  Has handled Trainings ? {{author.trainings.length > 0 ? 'Yes' : 'No'}}</h1>   -->
      <h1>{{author.name}}  Has handled Trainings ? {{isTrainingHandled}}</h1>  
</template>
.....................................................................................
			Computed Properties vs Normal Methods
...................................................................................
<script setup>
import { computed, reactive } from 'vue';

const author = reactive({
    name: 'Subramanian',
    trainings: [
        'Vue 3 Basic to intermediate',
        'MicroServices using Spring Cloud'
    ]
})
//computed Property: 
// const isTrainingHandled = computed(() => {
//     return author.trainings.length > 0 ? 'Yes' : 'No'
// })
//normal js method
const isTrainingHandled =() => {
    return author.trainings.length > 0 ? 'Yes' : 'No'
}

</script>
<template>
    <!-- Immperative way of handling js expressions -->
    <!-- <h1>{{author.name}}  Has handled Trainings ? {{author.trainings.length > 0 ? 'Yes' : 'No'}}</h1>   -->
      <h1>{{author.name}}  Has handled Trainings ? {{isTrainingHandled()}}</h1>  
</template>
.....................................................................................
	Dynamic Props: The state of one component becomes props to another component
.....................................................................................

Parent Component

App.vue
<script setup>
import { ref } from 'vue';
import  Counter  from './Counter.vue'
const counter = ref(10)
const inc = () => counter.value++
</script>
<template>
    <div>
        <Counter :counter="counter" :inc="inc" />
    </div>
</template>
<style>

</style>

Child Component

<script setup>
const props = defineProps({
    counter: Number,
    inc:Function
})
console.log(props)
</script>
<template>
    <div>
        <h1>Counter App</h1>
        <h2>Value {{props.counter}}</h2>
        <button @click="inc">+</button>
    </div>
</template>
<style>

</style>
...................................................................................
			  Component Communications
...................................................................................
Component communications enable data sharing.

There are three patterns

1.parent to child
  via props pattern
2.child to parent
    Custom Events -Event emitter pattern
3.across the components
   Via Statement libs  - Vuex/Pionon

.....................................................................................
			  Event Emitter Pattern
....................................................................................

Child component can emit event along with data, where as parent component can listen for data.

Event emitter syntax:

in the child component

const emitter =  defineEmits(['change','remove','save'])
<script setup>
import { ref } from 'vue';
const emit = defineEmits(['onRequest'])
const counter = ref(0)
//listener to emit event
const onSend = () => {
    counter.value++
    emit('onRequest', counter.value)
}
</script>
<template>
    <h1>Child</h1>
    <button @click="onSend">Send To Parent</button>
    <!-- Access emit method inside template refered with $ -->
    <button @click="$emit('onRequest',counter++)">Send To Parent</button>

</template>
<style>

</style>
.....................................................................................
			   Fall Through Attributes
	     (Sending HTML Attributes from the parent Component to Child Component)
.....................................................................................

Attribute inheritance:
......................
  A Fall through attribute is an attribute or v-on listeners that is passed to component but it is not explicitly declared in the receiving components(child components) via props or emits.  

Parent:
App.vue
<script setup>
import { ref } from 'vue';
import MyButton from './MyButton.vue';
const title = ref('Click')
</script>
<template>
    <!-- sending html attribute as prop : fall through attributes -->
    <MyButton :title="title"  class="fancy-btn"  :disabled="true"></MyButton>
</template>
<style>
.fancy-btn {
    background-color: #4CAF50;
    border: none;
    color: white;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline;
    font-size: 16px;
}
</style>

Child : MyButton.vue
<script setup>
const props = defineProps(['title'])
</script>
<template>
    <button>{{props.title}}</button>
</template>
<style>

</style>
....................................................................................
 How to access the attributes passed from parent in the child compoent

Two places:

1.inside template
2.inside script block

<script>
export default {
    created(){
        console.log(this.$attrs)
    }
}
</script>

<script setup>
const props = defineProps(['title'])
</script>
<template>
    <button>{{props.title}}</button>
     <div>{{$attrs}}</div>
</template>
<style>

</style>
.................................................................................
		Can we override the dom attributes in the child component
...................................................................................
Yes possible except css properties by default

in the style we need add attribute in the style tag scoped

<script>
export default {
    created(){
        console.log(this.$attrs)
    }
}
</script>

<script setup>
const props = defineProps(['title'])
</script>
<template>
    <button>{{props.title}}</button>
     <!-- <div>{{$attrs}}</div> -->
</template>
<style scoped>
.fancy-btn {
    color:red
}
</style>
.....................................................................................
			Can we add new "class" to the component

yes,We can

When add new classes , the new css classes to be merged as part of old css.

<script>
export default {
    created(){
        console.log(this.$attrs)
    }
}
</script>

<script setup>
const props = defineProps(['title'])
</script>
<template>
    <button class="large">{{props.title}}</button>
     <!-- <div>{{$attrs}}</div> -->
</template>
<style scoped>
/* .fancy-btn {
    color:red
} */
.large {
    color: rgb(228, 7, 7);
}
</style>

output:
<button class="large fancy-btn" data-v-960f1381="">Click</button>
..................................................................................
			How to prevent Attribute inheritance
..................................................................................

yes we can.

<script>
export default {
    created(){
        console.log(this.$attrs)
    },
    //inheritAttrs :false - to disable attribute inheritance..
}
</script>

<script setup>
const props = defineProps(['title'])
</script>
<template>
    <button class="large">{{props.title}}</button>
     <!-- <div>{{$attrs}}</div> -->
</template>
<style scoped>
/* .fancy-btn {
    color:red
} */
.large {
    color: rgb(228, 7, 7);
}
</style>
............................************.............................................
			Slots - Component as Prop/DOM element as Prop
....................................................................................

How to represent component inside template?

<MyComponent>?</MyComponent>
<MyComponent/>

			
<MyComponent>
   You are sending component/html element =>Slot content
</MyComponent>

<Layout>
	<Header>
	    <Menu></Menu>
        </Header>
</Layout>

in order to access element/component as prop inside child component vue offers
built in component "slot" - which is place holder where the elements to be inserted

Parent Component
<script setup>
import ChildSlot from './ChildSlot.vue';

</script>
<template>
   <ChildSlot>
      <h1>Slot Content</h1>
      <h1>Slot Content</h1>
      <h1>Slot Content</h1>
      <h1>Slot Content</h1>
      <h1>Slot Content</h1>
      <h1>Slot Content</h1>
      <h1>Slot Content</h1>

   </ChildSlot>
</template>
<style>

</style>


Child Component

ChildSlot.vue
<script setup>

</script>
<template>
    <div>
        <h1>Child</h1>
        <slot></slot>
    </div>
</template>
<style>

</style>
.....................................................................................
			  Fallback content
.....................................................................................

Parent Component
<script setup>
import ChildSlot from './ChildSlot.vue';

</script>
<template>
    <ChildSlot>
    </ChildSlot>
    <ChildSlot>
        <h3>How are you?</h3>
    </ChildSlot>
</template>
<style>

</style>


Child Component

<script setup>

</script>
<template>
    <div>
        <h1>Child</h1>
        <slot>
            Fallback Content Goes here
        </slot>
    </div>
</template>
<style>
</style>
...................................XXXXX...........................................
				Multi Slot
...................................................................................

We can have more than one Slots

Without slot
<Layout>
  <Header/>
  <Body/>
  <Footer/>
</Layout>

<Layout>
  <Header>
	<!--Header information -->
  </Header>
  <Body>
	<!--Body information -->
  </Body>
  <Footer>
       <!--Footer information -->
  </Footer>
</Layout>

eg:
Child
<slot name="header"></slot>
Parent
<template v-slot:header></template>

App.vue -Parent:
<script setup>
import Layout from './Layout.vue'
</script>
<template>
    <h1>Vue Application</h1>
    <Layout>
        <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:main>
            <p>This is body</p>
        </template>
        <template v-slot:footer>
            <h3>Footer</h3>
        </template>
    </Layout>
</template>
<style>

</style>

Child

Layout.vue

<script setup>

</script>
<template>
    <header>
        <slot name="header">
            <h1>Default Header</h1>
        </slot>
    </header>
    <main>
        <slot name="main">
            <p>This is default Main</p>
        </slot>

    </main>
    <footer>
        <slot name="footer">
            <h1>Default Footer</h1>
        </slot>

    </footer>
</template>
<style>

</style>
................................................................................
			Without V-Slot Directive , we can use #name

      <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:main>
            <p>This is body</p>
        </template>
        <template v-slot:footer>
            <h3>Footer</h3>
        </template>


      <template #header>
            <h1>Header</h1>
        </template>
        <template #main>
            <p>This is body</p>
        </template>
        <template #footer>
            <h3>Footer</h3>
        </template>

<script setup>
import Layout from './Layout.vue'
</script>
<template>
    <h1>Vue Application</h1>
    <Layout>
        <!-- <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:main>
            <p>This is body</p>
        </template>
        <template v-slot:footer>
            <h3>Footer</h3>
        </template> -->
        <template #header>
            <h1>Header</h1>
        </template>
        <template #main>
            <p>This is body</p>
        </template>
        <template #footer>
            <h3>Footer</h3>
        </template>
    </Layout>
</template>
<style>

</style>
.....................................................................................
				Default slots
....................................................................................
The slot without name is called "default slot"

Child:
    <main>
        <!-- <slot name="main">
            <p>This is default Main</p>
        </slot> -->
        <!-- Default Slot : Slot without Name -->
        <slot>
            <p>This is default Main</p>

        </slot>

    </main>

Parent:
 <template #default>
 </template>


eg:
Parent Component
<script setup>
import Layout from './Layout.vue'
</script>
<template>
    <h1>Vue Application</h1>
    <Layout>
        <!-- <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:main>
            <p>This is body</p>
        </template>
        <template v-slot:footer>
            <h3>Footer</h3>
        </template> -->
        <template #header>
            <h1>Header</h1>
        </template>
        <template #default>
            <p>This is body</p>
        </template>
        <template #footer>
            <h3>Footer</h3>
        </template>
    </Layout>
</template>
<style>

</style>

child Component:

<script setup>

</script>
<template>
    <header>
        <slot name="header">
            <h1>Default Header</h1>
        </slot>
    </header>
    <main>
        <!-- <slot name="main">
            <p>This is default Main</p>
        </slot> -->
        <!-- Default Slot : Slot without Name -->
        <slot>
            <p>This is default Main</p>

        </slot>

    </main>
    <footer>
        <slot name="footer">
            <h1>Default Footer</h1>
        </slot>

    </footer>
</template>
<style>

</style>
...................................................................................
				Dynamic Slots
...................................................................................

The slot name can be dynamic

Static slot:

<template v-slot:header>
<template #header>

Dynamic Slot:

const header = ref('header')

<template v-slot:[header]>
<template #[header]>

<script setup>
import { ref } from 'vue';
import Layout from './Layout.vue'

const header =ref('header')
</script>
<template>
    <h1>Vue Application</h1>
    <Layout>
        <!-- <template v-slot:header>
            <h1>Header</h1>
        </template>
        <template v-slot:main>
            <p>This is body</p>
        </template>
        <template v-slot:footer>
            <h3>Footer</h3>
        </template> -->
        <template #[header]>
            <h1>Header</h1>
        </template>
        <template #default>
            <p>This is body</p>
        </template>
        <template #footer>
            <h3>Footer</h3>
        </template>
    </Layout>
</template>
<style>
</style>
....................................................................................
			   Slots Scope
....................................................................................
Slots scope enable data accssibility for parent and child components.

There are two slot scope
1.Render scope
2.Scoped slots

Render Scope:
............
=> The slot content has access to the data scope of the parent component,since it is defined in the parent component.
=> The slot content does not have access to the child component's data.

	 "As rule of thumb every thing in the template compiled in the parent scope;
          every thing is compiled in the child template in the child scope"


Scoped Slots:
.............
   if you want to access data in the parent and child scope.

  "if parent component want to access child  state(data),the child can pass data to   parent via "slot" when rendering it"

  Slot can act as bridge between parent and child for data transfer.

Syntax:
 <slot :firstName="firstName" :age="age" />


eg:
Child -ScopeSlot.vue
<script setup>
import {ref} from 'vue'
const message = ref('Hello')

</script>
<template>
    <!-- send data to parent via slot -->
    <slot :message="message"></slot>
</template>
<style>
</style>

Parent:
App.vue
<script setup>
import ScopeSlot from './ScopeSlot.vue';

</script>
<template>
    <h1>Scoped Slots</h1>
    <ScopeSlot v-slot="slotprops">
        {{slotprops.message}}
    </ScopeSlot>
</template>
<style>
</style>
**************************************************************************************
























 












































	   





